for循环扩展:
    break和continue 后可以加标记  结束或者跳过指定循环
    格式：
        标记:for(;;){
        break 标记;  //结束指定循环
        continue 标记;  //跳过指定循环
        }
方法的重载：
    一个类中允许存在一个以上的同名方法，只要它们的参数列表不同即可，域修饰符和返回值类型无关
    参数列表：个数不同，数据类型不同，顺序不同。
成员变量和局部变量的区别：
成员变量：
    1、定义在类中方法外，这个类都可以使用
    2、存在堆中的对象中
    3、有默认值，不赋值也可以使用
    4、随着对象的创建而创建，随着对象的销毁而释放
局部变量：
    1、定义在方法中、局部代码块中，只在所属区域有效
    2、存在栈内存的方法中
    3、没有默认值，不赋值也可以使用
    4、随着方法的调用而存在，随着方法的结束而释放
ArrayuList<E>  集合
    重点：底层是数组，查询快，增删慢，第一次扩容是0，第二次是10，第三次是1.5倍
    特点：
        1、大小可变数组的实现
        2、<E>(泛型)：指的是当前集合中存放的统一都是什么类型的。泛型只能是引用类型
        3、直接打印集合，不是地址值。打印的集合中的元素，没有元素则[]
        4、创建集合时，右侧的<>里面的泛型在jdk1.7后可以省略不写，但是<>不能省略
构造方法：
        ArrayLiat<E>()构造一个初始容量为10的空列表。
成员变量：
        boolean add(E e)将指定元素添加到此列表的尾部。
        E remove(int index) 移除此列表指定位置上的元素。返回被删除的元素
        E get(int index) 返回此列表中指定位置上的元素。
        int size() 返回此列表中的元素数。
        集合中存储基本数据类型，泛型为基本数据类型的包装类(将一个基本数据类型包装成一个引用类型)
String 类代表字符串。Java程序中的所有字符串字面值(如"abc")都作为此类的实列实现
    所有用引号引起来都是String对象
   特点：
    1、字符串是常量；它们的值在创建之后不能更改
    2、因为String对象是不可变的，所以可以共享

    构造方法：5+1
        String()创建一个空的字符串对象
        String(String original)根据字符串来创建一个字符串对象
        String(char[] value) 通过字符串数组来创建字符创建字符串对象
        String(byte[] bytes)通过字节数组来构造新的字符串对象
        String(byte[] bytes,int offset,int length)通过字节数组一部分来构造新的
            字符串对象直接用双引号引起来的也是一个字符串对象
        equals(Object anObjest):将此字符串域指定字符串对象进行比较。区分大小写
常量池：
    1、  jdk6在方法区   jdk7之后在堆内存中的常量池中
static关键字： 静态
    可以修饰成员变量和成员方法，一旦用static修饰后的成员变量和成员方法就只属于类的
static修饰的成员变量叫做静态变量
static修饰的成员方法叫做静态方法
访问静态变量和静态方法
   对象名.静态变量/静态方法  不推荐
   类名.静态变量/静态方法
静态方法：
  在本类中访问本类的静态方法可以省略类名不写
  静态方法中不能写this this代表对象  静态优先于所有对象
静态代码块：
static{

}
特点：
    1、类中方法外
    2、优先于构造方法执行
    3、在第一次创建对象时，只会执行唯一的一次
继承性：(共性抽取)
    将多个子类(派生类)相同的属性和行为抽取出来形成一个单独的父类(超类/基类)，子类继承父类，可以拥有父类
    所有非石油的属性和行为
    继承是多态的前提，没有继承就没有多态
    定义父类：
    子类的格式：{}
    public class 子类的名称 extends 父类的名称{}
成员变量重名时
    等号左边是谁就优先用谁，没有则向上找父类，父类没有编译报错
区分子类成员方法中重名的三种变量：
    局部变量    直接写变量名   通过就近原则查找
    子类的成员变量 this.成员变量
    父类的成员变量 super.成员变量
在继承关系中，成员方法重名时，创建子类访问成员方法：
    创建的对象时谁就优先用谁，没有则向上找父类，父类没有编译报错
注意事项：
    1、注解：@Override 写在方法上面，用于检测该方法是否是正确的覆盖重写
         如果本身就时正确的覆盖重写，不加注解也可以
    2、子类方法的返回值必须小于等于父类方法的返回值范围
         Object类是所有类的最高父类，String可以看作是Object的一个子类
    3、子类方法的权限修饰符必须大于等于父类方法的权限修饰符
       public protected  (default)   private
       (default):  不是一个关键字  而是什么都不写

覆盖重写使用场景：
    在不修改一个类的源代码时，想对这个类的一些功能加强时，就可以继承这个类，对这个类的
    某一个方法覆盖重写
在继承关系中，父类构造方法访问特点：
    1、子类构造方法中会默认隐含赠送一个super() 调用父类无参构造
    2、子类构造方法可以访问父类重载构造方法
    3、调用父类的构造方法 super() 必须是在子类构造方法中的第一个语句
    4、如果手动写了super(参数) 调用了父类的有参构造，super() 则不会赠送
    5、只有子类的构造方法才能调用父类的构造方法

super的用法：
    调用父类的成员变量   super.成员变量
    调用父类的成员方法   super.成员方法
    调用父类的构造方法   super([参数])  必须是构造方法中的第一个语句

this的用法：
    调用本类的成员变量    this.成员变量
    调用本类的成员方法    this.成员方法
    调用本类的构造方法    this([参数])  必须是构造方法中的第一个语句
java中继承的特点：
    1、java中是单继承(亲爸爸只有一个)  但是可以多级继承
    2、一个父类可以被多个子类继承
接口：
    接口不是类
    子类需要重写父接口中所有的抽象方法，如果不重写，则必须申明成抽象类
    接口不能new(实列化)
    可以直接调用父接口中的默认方法
    静态方法只能自己调用
    默认方法：如果多个父接口中有相同名称的默认方法，则子类必须重写
    单继承多实现
    就近原则
    接口可以继承接口可以有多个继承
    接口中的方法都默认都是抽象方法，可以省略修饰符 public abstract
    接口中无法定义成员变量，可以定义常量
    常量必须用public final static 定义
    如果有多个单词构成，则必须加_，而且要大写
    抽象类中可以有变量
    接口中不能有静态代码块
    多态：
    匿名内部类返回的是接口的子实现类，而且没有名字
    ==比较的是内存地址

    equals:
    调用者不能是null,否则会报空指针
    解决方法:
    Objects.equals(调用者，比较者)
    实际调用的是==
    基本类型没有equals
    只有包装类型和引用类型
    String 类会重写equals,重写以后比较多是值，大多数类都会重写equals
    包装类型的默认值都是空
    int默认值是0
    char
    dety
    boolean默认值是false
    long
    基本类型没有父类
    链表：
    单向链表
    双向链表
    单项环形链表
    双向环形链表
    增删块
    查询慢
    List集合
    特点：有序可以重复
    HashSet去重原理:
    往Haset添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值
    如果hash值不相同，说明是一个新元素，直接存储在这个位置上；
    如果hash值相同，然后判断equals,返回true，说明元素已经存在，不存,返回false,说明不是同一个元素，存储。
    相同哈希值的元素就这样存储在同一个哈希桶中，用链表连接，如果超过链表的阈值（8），则转换成红黑树存储数据。
    重写hashCode()一定要重写equals()